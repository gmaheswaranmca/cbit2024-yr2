Q **Binary Tree Maximum Path Sum** - [LeetCode 124]
https://leetcode.com/problems/binary-tree-maximum-path-sum/
A path in a binary tree is a sequence of nodes where each pair of adjacent nodes 
in the sequence has an edge connecting them. A node can only appear in the sequence at most once. 
Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the root of a binary tree, return the maximum path sum of any non-empty path.

Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
 
Constraints:
The number of nodes in the tree is in the range [1, 3 * 104].
-1000 <= Node.val <= 1000


Steps
    Define the Recursive Function:
        This function should take a node as input and 
        return the maximum path sum that starts from the node and 
        extends to either its left or right child.
    Base Case:
        If the node is None, return 0 because an empty subtree 
        contributes nothing to the path sum.
    Recursive Case:
        1. Recursively calculate the maximum path sum 
               for the left and right subtrees.
        2. Compute the maximum path sum that passes through 
            the current node and 
               includes 
            the left 
               and 
            right children.
        3. Update the global maximum path sum 
            if the current path sum 
               is greater than 
            the previously recorded maximum.
    Return Value:
        Return the maximum path sum that includes the current node and 
        extends to one of its subtrees.

Q **Construct Binary Tree from Preorder and Inorder Traversal** - [LeetCode 105]
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
### Approach to Solve

1. **Understanding the Relationship**:
   - In preorder traversal, 
        the first element is always the root of the subtree.
   - In inorder traversal, 
        elements to the left of the root belong to the left subtree, 
        and elements to the right belong to the right subtree.

2. **Recursive Construction**:
   - Use a recursive approach where:
     - The current subtree's root is the first element of the preorder array.
     - Find this root in the inorder array to determine the left and right subtrees.
     - Recursively construct the left and right subtrees.

3. **Steps**:
   - Start with the preorder and inorder arrays.
   - Extract the root from the preorder array.
   - Find the index of this root in the inorder array to split it into left and right subtrees.
   - Recursively construct the left and right subtrees using the respective parts of the preorder and inorder arrays.

Q **Lowest Common Ancestor of a Binary Tree** - [LeetCode 236]
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/

### Approach to Solve
1. **Recursive DFS Approach**:
   - Perform a Depth-First Search (DFS) starting from the root of the tree.
   - If the current node is `None` or matches either `p` or `q`, return the current node.
   - Recursively search the left and right subtrees.
   - If both `p` and `q` are found in separate subtrees (`left` and `right`), then the current node is the LCA.
   - If only one of `p` or `q` is found, return that node as a potential LCA for its subtree.
   - If neither `p` nor `q` is found in either subtree, return `None`.

2. **Base Case**:
   - If the current node is `None`, return `None`.
   - If the current node matches `p` or `q`, return the current node.

3. **Recursive Case**:
   - Recursively search the left subtree and store the result in `left`.
   - Recursively search the right subtree and store the result in `right`.

4. **Return Value**:
   - If both `left` and `right` are not `None`, it means `p` and `q` are found in different subtrees, so return the current node.
   - If only one of `left` or `right` is `None`, return the non-`None` value (potential LCA found in one subtree).
   - If both `left` and `right` are `None`, return `None`.


Q
**Kth Smallest Element in a BST** - [LeetCode 230]
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

Approach:
    inorder ie recursion 

Q
**Range Sum of BST** - [LeetCode 938]
https://leetcode.com/problems/range-sum-of-bst/

**Recursive DFS Approach**:
   - Perform a Depth-First Search (DFS) starting from the root of the tree.
   - Use the BST property to decide whether to explore left or right subtrees or to add the current node's value to the sum.
   - Traverse each node and add its value to the sum if it lies within the range `[L, R]`.